/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./ImportMultiImageCanvas/index.ts":
/*!*****************************************!*\
  !*** ./ImportMultiImageCanvas/index.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImportMultiImageCanvas: () => (/* binding */ ImportMultiImageCanvas)\n/* harmony export */ });\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nclass ImportMultiImageCanvas {\n  /**\n   * Empty constructor.\n   */\n  constructor() {\n    this._selectedImages = [];\n    this._imagesOutput = \"\";\n    this._uploadStatus = \"ready\";\n    this._maxFiles = 10;\n    this._maxFileSize = 5; // MB\n    this._heightControl = 0; // Custom height in pixels, 0 = auto\n    this._widthControl = 0; // Custom width in pixels, 0 = auto\n    this._viewOnly = false; // View-only mode\n    // Empty\n  }\n  /**\n   * Used to initialize the control instance. Controls can kick off remote server calls and other initialization actions here.\n   * Data-set values are not initialized here, use updateView.\n   * @param context The entire property bag available to control via Context Object; It contains values as set up by the customizer mapped to property names defined in the manifest, as well as utility functions.\n   * @param notifyOutputChanged A callback method to alert the framework that the control has new outputs ready to be retrieved asynchronously.\n   * @param state A piece of data that persists in one session for a single user. Can be set at any point in a controls life cycle by calling 'setControlState' in the Mode interface.\n   * @param container If a control is marked control-type='standard', it will receive an empty div element within which it can render its content.\n   */\n  init(context, notifyOutputChanged, state, container) {\n    this._container = container;\n    this._notifyOutputChanged = notifyOutputChanged;\n    this._context = context;\n    this.createUI();\n    this.bindEvents();\n  }\n  /**\n   * Called when any value in the property bag has changed. This includes field values, data-sets, global values such as container height and width, offline status, control metadata values such as label, visible, etc.\n   * @param context The entire property bag available to control via Context Object; It contains values as set up by the customizer mapped to names defined in the manifest, as well as utility functions\n   */\n  updateView(context) {\n    var _a;\n    this._context = context;\n    var needsUIUpdate = false;\n    // Load JsonDataImage input if provided\n    var currentJsonInput = ((_a = context.parameters.JsonDataImage) === null || _a === void 0 ? void 0 : _a.raw) || \"\";\n    // Check if JsonDataImage has changed (including from empty to data or vice versa)\n    if (currentJsonInput !== this._imagesOutput) {\n      this.loadImagesFromInput(currentJsonInput);\n      needsUIUpdate = true;\n    }\n    // Update max files if changed\n    if (context.parameters.maxFiles && context.parameters.maxFiles.raw !== null) {\n      var maxFiles = context.parameters.maxFiles.raw;\n      if (maxFiles > 0 && maxFiles !== this._maxFiles) {\n        this._maxFiles = maxFiles;\n        needsUIUpdate = true;\n      }\n    }\n    // Update max file size if changed\n    if (context.parameters.maxFileSize && context.parameters.maxFileSize.raw !== null) {\n      var maxFileSize = context.parameters.maxFileSize.raw;\n      if (maxFileSize > 0 && maxFileSize !== this._maxFileSize) {\n        this._maxFileSize = maxFileSize;\n        needsUIUpdate = true;\n      }\n    }\n    // Update height control if changed\n    if (context.parameters.HeightControl && context.parameters.HeightControl.raw !== null) {\n      var heightControl = context.parameters.HeightControl.raw;\n      if (heightControl >= 0 && heightControl !== this._heightControl) {\n        this._heightControl = heightControl;\n        this.updateContainerHeight();\n        needsUIUpdate = true;\n      }\n    }\n    // Update width control if changed\n    if (context.parameters.WidthControl && context.parameters.WidthControl.raw !== null) {\n      var widthControl = context.parameters.WidthControl.raw;\n      if (widthControl >= 0 && widthControl !== this._widthControl) {\n        this._widthControl = widthControl;\n        this.updateContainerWidth();\n        needsUIUpdate = true;\n      }\n    }\n    // Update view-only mode if changed\n    if (context.parameters.ViewOnly && context.parameters.ViewOnly.raw !== null) {\n      var viewOnly = context.parameters.ViewOnly.raw;\n      if (viewOnly !== this._viewOnly) {\n        this._viewOnly = viewOnly;\n        this.updateViewOnlyMode();\n        needsUIUpdate = true;\n      }\n    }\n    // Update UI if properties changed\n    if (needsUIUpdate) {\n      this.updateFileInfoDisplay();\n    }\n  }\n  /**\n   * Create the UI for the control\n   */\n  createUI() {\n    this._container.innerHTML = \"\\n            <div class=\\\"image-import-container\\\">\\n                <div class=\\\"drop-zone\\\" id=\\\"dropZone\\\">\\n                    <div class=\\\"drop-zone-content\\\" id=\\\"browseBtn\\\">\\n                        <div class=\\\"upload-icon\\\">\\uD83D\\uDCF7</div>\\n                        <h3>Drag & Drop Images Here</h3>\\n                        <p>or click to browse</p>\\n                        <p class=\\\"file-info\\\">Support: JPG, PNG, GIF, BMP (Max: \".concat(this._maxFiles, \" files, \").concat(this._maxFileSize, \"MB each)</p>\\n                        <div class=\\\"camera-preview\\\" id=\\\"cameraPreview\\\"></div>\\n                        <div class=\\\"action-buttons\\\">\\n                            <button type=\\\"button\\\" class=\\\"browse-btn\\\" id=\\\"browseBtn\\\">\\uD83D\\uDCF7 Take Photo</button>\\n                        </div>\\n                    </div>\\n                </div>\\n                <input type=\\\"file\\\" id=\\\"fileInput\\\" multiple accept=\\\"image/*\\\" style=\\\"display: none;\\\" />\\n                <div class=\\\"selected-images\\\" id=\\\"selectedImages\\\">\\n                    <div class=\\\"scroll-hint\\\">Scroll to see more \\u2195</div>\\n                </div>\\n                <div class=\\\"status-bar\\\" id=\\\"statusBar\\\">\\n                    <span id=\\\"statusText\\\">Ready to import images</span>\\n                </div>\\n            </div>\\n        \");\n    this.applyStyles();\n    this.getUIElements();\n    this.updateContainerHeight(); // Apply initial height setting\n    this.updateContainerWidth(); // Apply initial width setting\n    this.updateViewOnlyMode(); // Apply initial view-only setting\n  }\n  /**\n   * Get UI elements references\n   */\n  getUIElements() {\n    this._dropZone = this._container.querySelector('#dropZone');\n    this._fileInput = this._container.querySelector('#fileInput');\n  }\n  /**\n   * Update file info display when properties change\n   */\n  updateFileInfoDisplay() {\n    var fileInfoElement = this._container.querySelector('.file-info');\n    if (fileInfoElement) {\n      fileInfoElement.textContent = \"Support: JPG, PNG, GIF, BMP (Max: \".concat(this._maxFiles, \" files, \").concat(this._maxFileSize, \"MB each)\");\n    }\n  }\n  /**\n   * Update container height based on HeightControl property\n   */\n  updateContainerHeight() {\n    var container = this._container.querySelector('#selectedImages');\n    if (container) {\n      if (this._heightControl > 0) {\n        // Use custom height\n        container.style.maxHeight = \"\".concat(this._heightControl, \"px\");\n        container.style.overflowY = 'auto';\n      } else {\n        // Use default responsive behavior\n        container.style.maxHeight = '';\n        container.style.overflowY = '';\n      }\n      // Update scroll indicator after height change\n      this.updateScrollIndicator(container);\n    }\n  }\n  /**\n   * Update container width based on WidthControl property\n   */\n  updateContainerWidth() {\n    var container = this._container.querySelector('.image-import-container');\n    if (container) {\n      if (this._widthControl > 0) {\n        // Use custom width\n        container.style.maxWidth = \"\".concat(this._widthControl, \"px\");\n        container.style.width = \"\".concat(this._widthControl, \"px\");\n        container.style.margin = '0 auto'; // Center the container\n      } else {\n        // Use default responsive behavior\n        container.style.maxWidth = '';\n        container.style.width = '';\n        container.style.margin = '';\n      }\n    }\n  }\n  /**\n   * Update view-only mode based on ViewOnly property\n   */\n  updateViewOnlyMode() {\n    var dropZone = this._container.querySelector('#dropZone');\n    // const browseBtn = this._container.querySelector('#browseBtn') as HTMLButtonElement;\n    // const cameraBtn = this._container.querySelector('#cameraBtn') as HTMLButtonElement;\n    if (this._viewOnly) {\n      // Hide drop zone completely in view-only mode\n      dropZone.style.display = 'none';\n      // Add view-only class for styling\n      this._container.classList.add('view-only-mode');\n      // Update status message\n      this.updateStatus('View-only mode: Adding/editing images is disabled', 'info');\n    } else {\n      // Show drop zone in edit mode\n      dropZone.style.display = '';\n      // Remove view-only class\n      this._container.classList.remove('view-only-mode');\n      // Reset status message\n      this.updateStatus('Ready to import images', 'info');\n    }\n  }\n  /**\n   * Load images from input JSON string\n   */\n  loadImagesFromInput(jsonData) {\n    try {\n      if (!jsonData || jsonData.trim() === '' || jsonData === '[]') {\n        // Clear images if input is empty\n        this._selectedImages = [];\n        this._imagesOutput = jsonData || \"\"; // Keep the original input (empty string or [])\n        this.updateImageDisplay();\n        this.updateStatus('Ready to import images', 'info');\n        return;\n      }\n      var parsedData = JSON.parse(jsonData);\n      if (Array.isArray(parsedData)) {\n        // Validate and load images\n        var validImages = [];\n        for (var item of parsedData) {\n          if (this.isValidImageData(item)) {\n            validImages.push(item);\n          }\n        }\n        this._selectedImages = validImages;\n        this._imagesOutput = jsonData; // Keep the original input\n        this.updateImageDisplay();\n        if (validImages.length > 0) {\n          this.updateStatus(\"Loaded \".concat(validImages.length, \" image(s) successfully\"), 'success');\n        } else {\n          this.updateStatus('No valid images found in input data', 'error');\n        }\n      } else {\n        this.updateStatus('Invalid JSON format for images', 'error');\n      }\n    } catch (error) {\n      console.error('Error parsing JsonDataImage input:', error);\n      this.updateStatus('Error loading images from input data', 'error');\n    }\n  }\n  /**\n   * Validate if object is valid ImageData\n   */\n  isValidImageData(obj) {\n    var candidate = obj;\n    return candidate && typeof candidate.id === 'string' && typeof candidate.name === 'string' && typeof candidate.type === 'string' && typeof candidate.data === 'string' && typeof candidate.size === 'number' && typeof candidate.uploadDate === 'string';\n  }\n  /**\n   * Apply CSS styles to the control\n   */\n  applyStyles() {\n    // CSS is now loaded from external file via manifest\n    // No need to inject styles dynamically\n  }\n  /**\n   * Bind event handlers\n   */\n  bindEvents() {\n    // Drag and drop events\n    this._dropZone.addEventListener('dragover', this.handleDragOver.bind(this));\n    this._dropZone.addEventListener('dragleave', this.handleDragLeave.bind(this));\n    this._dropZone.addEventListener('drop', this.handleDrop.bind(this));\n    // Click to browse\n    this._dropZone.addEventListener('click', () => {\n      this._fileInput.click();\n    });\n    var browseBtn = this._container.querySelector('#browseBtn');\n    browseBtn === null || browseBtn === void 0 ? void 0 : browseBtn.addEventListener('click', e => {\n      e.stopPropagation();\n      this._fileInput.click();\n    });\n    // const cameraBtn = this._container.querySelector('#cameraBtn') as HTMLButtonElement;\n    // cameraBtn?.addEventListener('click', (e) => {\n    //     e.stopPropagation();\n    //     this.openCamera();\n    // });\n    // File input change\n    this._fileInput.addEventListener('change', this.handleFileSelect.bind(this));\n    // Global paste event (when control has focus)\n    this._container.addEventListener('paste', this.handlePaste.bind(this));\n    // Make container focusable for paste\n    this._container.setAttribute('tabindex', '0');\n  }\n  /**\n   * Handle drag over event\n   */\n  handleDragOver(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    this._dropZone.classList.add('dragover');\n  }\n  /**\n   * Handle drag leave event\n   */\n  handleDragLeave(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    this._dropZone.classList.remove('dragover');\n  }\n  /**\n   * Handle drop event\n   */\n  handleDrop(e) {\n    var _a;\n    e.preventDefault();\n    e.stopPropagation();\n    this._dropZone.classList.remove('dragover');\n    // Check view-only mode\n    if (this._viewOnly) {\n      this.updateStatus('View-only mode: Cannot add images', 'error');\n      return;\n    }\n    var files = (_a = e.dataTransfer) === null || _a === void 0 ? void 0 : _a.files;\n    if (files) {\n      this.processFiles(Array.from(files));\n    }\n  }\n  /**\n   * Handle file select from input\n   */\n  handleFileSelect(e) {\n    // Check view-only mode\n    if (this._viewOnly) {\n      this.updateStatus('View-only mode: Cannot add images', 'error');\n      return;\n    }\n    var target = e.target;\n    var files = target.files;\n    if (files) {\n      this.processFiles(Array.from(files));\n    }\n  }\n  /**\n   * Handle paste event\n   */\n  handlePaste(e) {\n    var _a;\n    e.preventDefault();\n    e.stopPropagation();\n    // Check view-only mode\n    if (this._viewOnly) {\n      this.updateStatus('View-only mode: Cannot add images', 'error');\n      return;\n    }\n    var items = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items;\n    if (!items) return;\n    var files = [];\n    for (var item of Array.from(items)) {\n      if (item.type.indexOf('image') !== -1) {\n        var file = item.getAsFile();\n        if (file) {\n          // Generate a name for pasted image\n          var timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n          var extension = this.getFileExtension(item.type);\n          var renamedFile = new File([file], \"pasted-image-\".concat(timestamp, \".\").concat(extension), {\n            type: item.type\n          });\n          files.push(renamedFile);\n        }\n      }\n    }\n    if (files.length > 0) {\n      this.processFiles(files);\n    }\n  }\n  updateImageNote(imageId, note) {\n    // Check view-only mode\n    if (this._viewOnly) {\n      this.updateStatus('View-only mode: Cannot edit notes', 'error');\n      return;\n    }\n    var image = this._selectedImages.find(img => img.id === imageId);\n    if (image) {\n      image.note = note;\n    }\n  }\n  /**\n   * Open camera to capture image\n   */\n  openCamera() {\n    // Check view-only mode\n    if (this._viewOnly) {\n      this.updateStatus('View-only mode: Cannot capture images', 'error');\n      return;\n    }\n    if (this._context.device && this._context.device.captureImage) {\n      this.updateStatus('Opening camera...', 'info');\n      this._context.device.captureImage().then(result => {\n        if (result && result.fileContent) {\n          this.processCameraImage(result);\n        } else {\n          this.updateStatus('No image captured', 'error');\n        }\n        return result;\n      }, error => {\n        console.error('Camera error:', error);\n        this.updateStatus('Failed to capture image. Camera may not be available.', 'error');\n        throw error;\n      }).catch(error => {\n        console.error('Camera capture failed:', error);\n      });\n    } else {\n      this.updateStatus('Camera not available on this device', 'error');\n    }\n  }\n  /**\n   * Process image captured from camera\n   */\n  processCameraImage(captureResult) {\n    try {\n      // Check file size limit\n      var maxSizeBytes = this._maxFileSize * 1024 * 1024;\n      if (captureResult.fileSize && captureResult.fileSize > maxSizeBytes) {\n        this.updateStatus(\"Captured image too large. Maximum size: \".concat(this._maxFileSize, \"MB\"), 'error');\n        return;\n      }\n      // Check file count limit\n      if (this._selectedImages.length >= this._maxFiles) {\n        this.updateStatus(\"Cannot add more images. Maximum \".concat(this._maxFiles, \" files allowed.\"), 'error');\n        return;\n      }\n      var timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      var fileName = captureResult.fileName || \"camera-photo-\".concat(timestamp, \".jpg\");\n      var imageData = {\n        id: \"img_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9)),\n        name: fileName,\n        size: captureResult.fileSize || 0,\n        type: captureResult.mimeType || 'image/jpeg',\n        data: captureResult.fileContent,\n        uploadDate: new Date().toISOString(),\n        note: \"\"\n      };\n      this._selectedImages.push(imageData);\n      this.updateImageDisplay();\n      this.updateOutput();\n      this.updateStatus(\"Photo captured successfully. Total: \".concat(this._selectedImages.length), 'success');\n    } catch (error) {\n      console.error('Error processing camera image:', error);\n      this.updateStatus('Error processing captured image', 'error');\n    }\n  }\n  /**\n   * Get file extension from MIME type\n   */\n  getFileExtension(mimeType) {\n    var extensions = {\n      'image/png': 'png',\n      'image/jpeg': 'jpg',\n      'image/jpg': 'jpg',\n      'image/gif': 'gif',\n      'image/bmp': 'bmp',\n      'image/webp': 'webp'\n    };\n    return extensions[mimeType] || 'png';\n  }\n  /**\n   * Check if running on mobile device\n   */\n  isMobileDevice() {\n    return /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n  }\n  /**\n   * Handle image click to show full size\n   */\n  handleImageClick(imageId) {\n    var image = this._selectedImages.find(img => img.id === imageId);\n    if (!image) return;\n    // Always show modal for now (works on both mobile and desktop)\n    this.showImageModal(image);\n  }\n  /**\n   * Show image in modal for both desktop and mobile with zoom/pan functionality.\n   */\n  showImageModal(image) {\n    // Create modal overlay\n    var modal = document.createElement('div');\n    modal.className = 'image-modal-overlay';\n    modal.innerHTML = \"\\n            <div class=\\\"image-modal\\\">\\n                <div class=\\\"image-modal-header\\\">\\n                    <h3>\".concat(image.name, \"</h3>\\n                    <button class=\\\"image-modal-close\\\">&times;</button>\\n                </div>\\n                <div class=\\\"image-modal-content\\\">\\n                    <img src=\\\"data:\").concat(image.type, \";base64,\").concat(image.data, \"\\\" alt=\\\"\").concat(image.name, \"\\\" class=\\\"image-modal-img\\\" />\\n                </div>\\n                <div class=\\\"image-modal-footer\\\">\\n                    <p>Size: \").concat(this.formatFileSize(image.size), \" | Type: \").concat(image.type, \"</p>\\n                    \").concat(image.note ? \"<p>Note: \".concat(image.note, \"</p>\") : '', \"\\n                    <p class=\\\"zoom-hint\\\">\").concat(this.isMobileDevice() ? 'Pinch to zoom, drag to pan' : 'Scroll/Double-click to zoom, drag to pan', \"</p>\\n                </div>\\n            </div>\\n        \");\n    // Add styles for modal\n    var modalStyles = \"\\n            .image-modal-overlay {\\n                position: fixed;\\n                top: 0;\\n                left: 0;\\n                width: 100%;\\n                height: 100%;\\n                background: rgba(0, 0, 0, 0.85);\\n                display: flex;\\n                justify-content: center;\\n                align-items: center;\\n                z-index: 10000;\\n            }\\n            .image-modal {\\n                background: white;\\n                border-radius: 8px;\\n                max-width: 90vw;\\n                max-height: 90vh;\\n                display: flex;\\n                flex-direction: column;\\n                cursor: default;\\n                box-shadow: 0 5px 15px rgba(0,0,0,0.3);\\n            }\\n            .image-modal-header {\\n                display: flex;\\n                justify-content: space-between;\\n                align-items: center;\\n                padding: 15px 20px;\\n                border-bottom: 1px solid #edebe9;\\n            }\\n            .image-modal-header h3 {\\n                margin: 0;\\n                color: #323130;\\n                font-size: 16px;\\n                font-weight: 600;\\n                overflow: hidden;\\n                text-overflow: ellipsis;\\n                white-space: nowrap;\\n                max-width: calc(100% - 40px);\\n            }\\n            .image-modal-close {\\n                background: none;\\n                border: none;\\n                font-size: 24px;\\n                color: #605e5c;\\n                cursor: pointer;\\n                padding: 0;\\n                width: 30px;\\n                height: 30px;\\n                display: flex;\\n                align-items: center;\\n                justify-content: center;\\n                flex-shrink: 0;\\n            }\\n            .image-modal-close:hover {\\n                color: #d13438;\\n                background: #fde7e9;\\n                border-radius: 50%;\\n            }\\n            .image-modal-content {\\n                padding: 0; /* Remove padding */\\n                display: flex;\\n                justify-content: center;\\n                align-items: center;\\n                flex-grow: 1; /* Allow content to fill space */\\n                overflow: hidden; /* Important for panning */\\n                position: relative;\\n            }\\n            .image-modal-img {\\n                max-width: 100%;\\n                max-height: 100%;\\n                object-fit: contain;\\n                cursor: zoom-in;\\n                transition: transform 0.2s ease-out;\\n                will-change: transform; /* Performance hint */\\n                image-rendering: -webkit-optimize-contrast;\\n                image-rendering: high-quality;\\n            }\\n            .image-modal-footer {\\n                padding: 15px 20px;\\n                border-top: 1px solid #edebe9;\\n                background: #f8f9fa;\\n                border-radius: 0 0 8px 8px;\\n            }\\n            .image-modal-footer p {\\n                margin: 5px 0;\\n                font-size: 12px;\\n                color: #605e5c;\\n            }\\n            .zoom-hint {\\n                font-style: italic;\\n                color: #a19f9d !important;\\n            }\\n            \\n            /* Mobile specific styles */\\n            @media (max-width: 768px) {\\n                .image-modal {\\n                    max-width: 100vw;\\n                    max-height: 100vh;\\n                    width: 100%;\\n                    height: 100%;\\n                    border-radius: 0;\\n                }\\n                .image-modal-content {\\n                    padding: 0;\\n                }\\n                .image-modal-header, .image-modal-footer {\\n                    padding: 10px 15px;\\n                }\\n                .image-modal-header h3 {\\n                    font-size: 14px;\\n                }\\n                .image-modal-footer p {\\n                    font-size: 11px;\\n                }\\n            }\\n        \";\n    // Add styles to head if not already added\n    if (!document.getElementById('image-modal-styles')) {\n      var styleSheet = document.createElement('style');\n      styleSheet.id = 'image-modal-styles';\n      styleSheet.textContent = modalStyles;\n      document.head.appendChild(styleSheet);\n    }\n    document.body.appendChild(modal);\n    var closeBtn = modal.querySelector('.image-modal-close');\n    var img = modal.querySelector('.image-modal-img');\n    var modalContent = modal.querySelector('.image-modal-content');\n    var scale = 1;\n    var isPanning = false;\n    var point = {\n      x: 0,\n      y: 0\n    };\n    var translate = {\n      x: 0,\n      y: 0\n    };\n    var lastClickTime = 0;\n    var applyTransform = function applyTransform() {\n      var smooth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      img.style.transition = smooth ? 'transform 0.2s ease-out' : 'none';\n      img.style.transform = \"translate(\".concat(translate.x, \"px, \").concat(translate.y, \"px) scale(\").concat(scale, \")\");\n    };\n    var setCursor = () => {\n      if (scale > 1) {\n        img.style.cursor = 'grab';\n      } else {\n        img.style.cursor = 'zoom-in';\n      }\n    };\n    var closeModal = () => {\n      document.body.removeChild(modal);\n      document.removeEventListener('keydown', handleEscape);\n    };\n    var handleEscape = e => {\n      if (e.key === 'Escape') {\n        closeModal();\n      }\n    };\n    closeBtn.addEventListener('click', closeModal);\n    modal.addEventListener('click', e => {\n      if (e.target === modal) {\n        closeModal();\n      }\n    });\n    document.addEventListener('keydown', handleEscape);\n    // --- Desktop Mouse Events ---\n    img.addEventListener('mousedown', e => {\n      if (scale <= 1) return;\n      e.preventDefault();\n      isPanning = true;\n      point = {\n        x: e.clientX - translate.x,\n        y: e.clientY - translate.y\n      };\n      img.style.cursor = 'grabbing';\n    });\n    img.addEventListener('mousemove', e => {\n      if (!isPanning) return;\n      e.preventDefault();\n      translate.x = e.clientX - point.x;\n      translate.y = e.clientY - point.y;\n      applyTransform();\n    });\n    img.addEventListener('mouseup', () => {\n      isPanning = false;\n      setCursor();\n    });\n    img.addEventListener('mouseleave', () => {\n      isPanning = false;\n      setCursor();\n    });\n    img.addEventListener('dblclick', e => {\n      e.preventDefault();\n      var newScale = scale > 1 ? 1 : 2;\n      if (newScale === 1) {\n        translate = {\n          x: 0,\n          y: 0\n        };\n      }\n      scale = newScale;\n      applyTransform(true);\n      setCursor();\n    });\n    // --- Mouse Wheel Zoom ---\n    modalContent.addEventListener('wheel', e => {\n      e.preventDefault();\n      var delta = e.deltaY > 0 ? -0.1 : 0.1;\n      var newScale = Math.max(1, Math.min(scale + delta, 5));\n      if (newScale === 1) {\n        translate = {\n          x: 0,\n          y: 0\n        };\n      }\n      scale = newScale;\n      applyTransform();\n      setCursor();\n    });\n    // --- Mobile Touch Events ---\n    var initialDistance = -1;\n    var initialScale = 1;\n    var getDistance = touches => {\n      return Math.hypot(touches[0].pageX - touches[1].pageX, touches[0].pageY - touches[1].pageY);\n    };\n    img.addEventListener('touchstart', e => {\n      if (e.touches.length === 2) {\n        e.preventDefault();\n        isPanning = false;\n        initialDistance = getDistance(e.touches);\n        initialScale = scale;\n      } else if (e.touches.length === 1 && scale > 1) {\n        e.preventDefault();\n        isPanning = true;\n        point = {\n          x: e.touches[0].clientX - translate.x,\n          y: e.touches[0].clientY - translate.y\n        };\n      }\n    });\n    img.addEventListener('touchmove', e => {\n      e.preventDefault();\n      if (e.touches.length === 2 && initialDistance > 0) {\n        // Pinch zoom\n        isPanning = false;\n        var newDistance = getDistance(e.touches);\n        scale = initialScale * (newDistance / initialDistance);\n        scale = Math.max(1, Math.min(scale, 5)); // Clamp scale\n        applyTransform();\n      } else if (e.touches.length === 1 && isPanning) {\n        // Pan\n        translate.x = e.touches[0].clientX - point.x;\n        translate.y = e.touches[0].clientY - point.y;\n        applyTransform();\n      }\n    });\n    img.addEventListener('touchend', e => {\n      if (e.touches.length < 2) initialDistance = -1;\n      if (e.touches.length < 1) isPanning = false;\n      if (scale <= 1) {\n        scale = 1;\n        translate = {\n          x: 0,\n          y: 0\n        };\n        applyTransform(true);\n      }\n    });\n    setCursor();\n  }\n  /**\n   * Process selected files\n   */\n  processFiles(files) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var imageFiles = files.filter(file => file.type.startsWith('image/'));\n      if (imageFiles.length === 0) {\n        this.updateStatus('No valid image files selected', 'error');\n        return;\n      }\n      // Check file count limit\n      if (this._selectedImages.length + imageFiles.length > this._maxFiles) {\n        this.updateStatus(\"Cannot add more images. Maximum \".concat(this._maxFiles, \" files allowed.\"), 'error');\n        return;\n      }\n      // Check file size limit\n      var maxSizeBytes = this._maxFileSize * 1024 * 1024; // Convert MB to bytes\n      var oversizedFiles = imageFiles.filter(file => file.size > maxSizeBytes);\n      if (oversizedFiles.length > 0) {\n        var oversizedNames = oversizedFiles.map(f => f.name).join(', ');\n        this.updateStatus(\"File(s) too large: \".concat(oversizedNames, \". Maximum size: \").concat(this._maxFileSize, \"MB\"), 'error');\n        return;\n      }\n      this.updateStatus('Processing images...', 'info');\n      try {\n        var newImages = [];\n        for (var file of imageFiles) {\n          var base64Data = yield this.fileToBase64(file);\n          var imageData = {\n            id: \"img_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9)),\n            name: file.name,\n            size: file.size,\n            type: file.type,\n            data: base64Data,\n            uploadDate: new Date().toISOString(),\n            note: \"\"\n          };\n          newImages.push(imageData);\n        }\n        this._selectedImages.push(...newImages);\n        this.updateImageDisplay();\n        this.updateOutput();\n        this.updateStatus(\"\".concat(newImages.length, \" image(s) added successfully. Total: \").concat(this._selectedImages.length), 'success');\n      } catch (error) {\n        console.error('Error processing files:', error);\n        this.updateStatus('Error processing images', 'error');\n      }\n    });\n  }\n  /**\n   * Convert file to base64\n   */\n  fileToBase64(file) {\n    return new Promise((resolve, reject) => {\n      var reader = new FileReader();\n      reader.onload = () => {\n        var result = reader.result;\n        // Remove data URL prefix (data:image/jpeg;base64,)\n        var base64 = result.split(',')[1];\n        resolve(base64);\n      };\n      reader.onerror = reject;\n      reader.readAsDataURL(file);\n    });\n  }\n  /**\n   * Update the display of selected images\n   */\n  updateImageDisplay() {\n    var container = this._container.querySelector('#selectedImages');\n    if (this._selectedImages.length === 0) {\n      container.innerHTML = '';\n      container.classList.remove('has-scroll');\n      return;\n    }\n    container.innerHTML = this._selectedImages.map(image => \"\\n            <div class=\\\"image-preview\\\" data-id=\\\"\".concat(image.id, \"\\\">\\n                \").concat(!this._viewOnly ? \"<button class=\\\"remove-btn\\\" data-image-id=\\\"\".concat(image.id, \"\\\">&times;</button>\") : '', \"\\n                <img src=\\\"data:\").concat(image.type, \";base64,\").concat(image.data, \"\\\" alt=\\\"\").concat(image.name, \"\\\" class=\\\"preview-img\\\" data-image-id=\\\"\").concat(image.id, \"\\\" />\\n                <div class=\\\"image-info\\\">\\n                    <div class=\\\"image-name\\\">\").concat(image.name, \"</div>\\n                    \").concat(!this._viewOnly ? \"<input type=\\\"text\\\" class=\\\"image-note\\\" data-image-id=\\\"\".concat(image.id, \"\\\" \\n                               placeholder=\\\"Add note...\\\" value=\\\"\").concat(image.note || '', \"\\\" \\n                               maxlength=\\\"100\\\" />\") : \"<div class=\\\"image-note-readonly\\\">\".concat(image.note || 'No note', \"</div>\"), \"\\n                </div>\\n            </div>\\n        \")).join('');\n    // Add remove event listeners to all remove buttons\n    var removeButtons = container.querySelectorAll('.remove-btn');\n    removeButtons.forEach(button => {\n      button.addEventListener('click', e => {\n        e.preventDefault();\n        e.stopPropagation();\n        // Check view-only mode\n        if (this._viewOnly) {\n          this.updateStatus('View-only mode: Cannot remove images', 'error');\n          return;\n        }\n        var imageId = e.target.getAttribute('data-image-id');\n        if (imageId) {\n          this.removeImage(imageId);\n        }\n      });\n    });\n    // Add note input event listeners\n    var noteInputs = container.querySelectorAll('.image-note');\n    noteInputs.forEach(input => {\n      input.addEventListener('input', e => {\n        // Check view-only mode\n        if (this._viewOnly) {\n          this.updateStatus('View-only mode: Cannot edit notes', 'error');\n          return;\n        }\n        var target = e.target;\n        var imageId = target.getAttribute('data-image-id');\n        if (imageId) {\n          this.updateImageNote(imageId, target.value);\n        }\n      });\n      input.addEventListener('blur', e => {\n        // Check view-only mode\n        if (this._viewOnly) {\n          return;\n        }\n        var target = e.target;\n        var imageId = target.getAttribute('data-image-id');\n        if (imageId) {\n          this.updateImageNote(imageId, target.value);\n          this.updateOutput(); // Update output when focus leaves input\n        }\n      });\n    });\n    // Add image click event listeners for full-size view\n    var previewImages = container.querySelectorAll('.preview-img');\n    previewImages.forEach(img => {\n      img.addEventListener('click', e => {\n        e.preventDefault();\n        e.stopPropagation();\n        var imageId = e.target.getAttribute('data-image-id');\n        if (imageId) {\n          this.handleImageClick(imageId);\n        }\n      });\n    });\n    // Check if container needs scroll indicator\n    this.updateScrollIndicator(container);\n  }\n  /**\n   * Update scroll indicator for images container\n   */\n  updateScrollIndicator(container) {\n    // Small delay to ensure DOM is fully rendered\n    setTimeout(() => {\n      var hasScrollableContent = container.scrollHeight > container.clientHeight;\n      if (hasScrollableContent) {\n        container.classList.add('has-scroll');\n      } else {\n        container.classList.remove('has-scroll');\n      }\n    }, 100);\n  }\n  /**\n   * Remove an image from the selection\n   */\n  removeImage(imageId) {\n    // Check view-only mode\n    if (this._viewOnly) {\n      this.updateStatus('View-only mode: Cannot remove images', 'error');\n      return;\n    }\n    this._selectedImages = this._selectedImages.filter(img => img.id !== imageId);\n    this.updateImageDisplay();\n    this.updateOutput();\n    this.updateStatus(\"Image removed. Total: \".concat(this._selectedImages.length), 'info');\n    // Update scroll indicator after removal\n    var container = this._container.querySelector('#selectedImages');\n    if (container) {\n      this.updateScrollIndicator(container);\n    }\n  }\n  /**\n   * Format file size for display\n   */\n  formatFileSize(bytes) {\n    if (bytes === 0) return '0 Bytes';\n    var k = 1024;\n    var sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    var i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n  /**\n   * Update the output for Canvas App\n   */\n  updateOutput() {\n    var newOutput = JSON.stringify(this._selectedImages);\n    if (this._imagesOutput !== newOutput) {\n      this._imagesOutput = newOutput;\n      this._notifyOutputChanged();\n    }\n  }\n  /**\n   * Update status message\n   */\n  updateStatus(message) {\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'info';\n    var statusBar = this._container.querySelector('#statusBar');\n    var statusText = this._container.querySelector('#statusText');\n    statusText.textContent = message;\n    statusBar.className = \"status-bar status-\".concat(type);\n    this._uploadStatus = type;\n  }\n  /**\n   * It is called by the framework prior to a control receiving new data.\n   * @returns an object based on nomenclature defined in manifest, expecting object[s] for property marked as \"bound\" or \"output\"\n   */\n  getOutputs() {\n    return {\n      JsonDataImage: this._imagesOutput\n    };\n  }\n  /**\n   * Called when the control is to be removed from the DOM tree. Controls should use this call for cleanup.\n   * i.e. cancelling any pending remote calls, removing listeners, etc.\n   */\n  destroy() {\n    // Remove event listeners\n    if (this._dropZone) {\n      this._dropZone.removeEventListener('dragover', this.handleDragOver.bind(this));\n      this._dropZone.removeEventListener('dragleave', this.handleDragLeave.bind(this));\n      this._dropZone.removeEventListener('drop', this.handleDrop.bind(this));\n    }\n    if (this._fileInput) {\n      this._fileInput.removeEventListener('change', this.handleFileSelect.bind(this));\n    }\n    // Clear data\n    this._selectedImages = [];\n    this._imagesOutput = \"\";\n    // CSS is managed by PCF framework, no need to remove manually\n  }\n}\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./ImportMultiImageCanvas/index.ts?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./ImportMultiImageCanvas/index.ts"](0, __webpack_exports__, __webpack_require__);
/******/ 	pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad = __webpack_exports__;
/******/ 	
/******/ })()
;
if (window.ComponentFramework && window.ComponentFramework.registerControl) {
	ComponentFramework.registerControl('CustomComponent.ImportMultiImageCanvas', pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad.ImportMultiImageCanvas);
} else {
	var CustomComponent = CustomComponent || {};
	CustomComponent.ImportMultiImageCanvas = pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad.ImportMultiImageCanvas;
	pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad = undefined;
}